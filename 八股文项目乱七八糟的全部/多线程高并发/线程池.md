```` 
package 线程池;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;

public class ThreadPoolDemo1 {
  /**
   * 1 自定义线程池
   * 创建一个线程池(完整入参):
   * 核心线程数为5 (corePoolSize),
   * 最大线程数为10 (maximumPoolSize),
   * 存活时间为60分钟(keepAliveTime),
   * 工作队列为LinkedBlockingQueue (workQueue),
   * 线程工厂为默认的DefaultThreadFactory (threadFactory),
   * 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).
   */
  private static ExecutorService THREAD_POOL=new ThreadPoolExecutor(5,10,60,
      TimeUnit.MINUTES,new LinkedBlockingDeque<Runnable>(),
      Executors.defaultThreadFactory(),
      new AbortPolicy());

  /**
   * 2 单线程线程池
   * 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue
   */
  private static ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();

  /**
   * 3 固定线程的线程池
   * 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,
   * 工作队列使用无界的LinkedBlockingQueue
   */
  private static ExecutorService fixedThreadPool=Executors.newFixedThreadPool(5);

  /**
   * 4 可以装无限（Integer.MAX_VALUE）线程的线程池
   * 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX_VALUE, 存活时间为60秒 该线程池可以无限扩展,
   * 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.
   */
  private static ExecutorService cachedThreadPool =Executors.newCachedThreadPool();

  /**
   * 5 定时线程池
   * 给定的延迟之后运行任务, 或者定期执行任务的线程池
   * 用了AQS抽象类下的DelayedWorkQueue
   */
  private static ScheduledExecutorService scheduledThreadPool =Executors.newScheduledThreadPool(5);


  public static void main(String[] args) throws ExecutionException, InterruptedException {
    /**
     * 证明submit/excute是异步的，并且在没有返回值的时候 submit method == execute method
     */
    //test1();

    /**
     * get方法会造成阻塞，下面的完全不会继续运行
     */
    //case2();

    //延时打印，线程池会自己new线程打印
    //case3();

    //future task,更加灵活，可以写成一个任务提交到线程池里面，也可以作为future得到结果，get方法来自future接口照样阻塞
    case4();





  }

  private static void case4() throws ExecutionException, InterruptedException {
    Callable<String> task=new Callable<String>() {
      @Override
      public String call() throws Exception {
        return "resultHere";
      }
    };

    FutureTask<String > futureTask=new FutureTask<>(task);
    THREAD_POOL.submit(futureTask);
    System.out.println(futureTask.get());

  }

  private static void case3() {

    /**
     * 例子3:
     * 有延迟的, 周期性执行异步任务
     * 本例子为: 延迟1秒, 每2秒执行1次
     * 会自动创建几个线程（5个以内）然后随机打印runnable 任务
     */
    scheduledThreadPool.scheduleAtFixedRate(()->{
      System.out.println("this is " + Thread.currentThread().getName());
    },1,1,TimeUnit.SECONDS);
  }

  private static void case2() throws ExecutionException, InterruptedException {

    /**
     * 例子2: 有返回结果的异步任务
     */
    Future<List<String>> future=THREAD_POOL.submit(
        new Callable<List<String>>() {
          @Override
          public List<String> call() throws Exception {
            TimeUnit.SECONDS.sleep(5);
            List<String> result = new ArrayList<>();
            result.add("JoonWhee");
            return result;
          }


  });

    List<String> result=future.get();
    System.out.println("阻塞五秒后的答案 "+result);
    THREAD_POOL.submit(()->{
      System.out.println("execute 没有返回值 lambda写法");
    });

  }

  private static void test1() {
    /**
     * 例子1: 没有返回结果的异步任务 Runnable，并且用沉睡10s证明是异步的
     */
    THREAD_POOL.submit(
        new Runnable() {
          @Override
          public void run() {
            try {
              TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
              e.printStackTrace();
            }
            System.out.println("execute 没有返回值 阻塞5秒应该在最后出现 ");
          }
        }
    );

    THREAD_POOL.execute(
        new Runnable() {
          @Override
          public void run() {
            System.out.println("execute 没有返回值 没有等待");
          }
        }
    );

    THREAD_POOL.submit(()->{
      System.out.println("execute 没有返回值 lambda写法");
    });
  }

}

````
